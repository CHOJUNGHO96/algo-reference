# 콘텐츠 품질 검증 규칙

## 목적
모든 AI 생성 알고리즘 콘텐츠가 프로덕션 사용을 위한 품질 기준을 충족하도록 보장합니다.

---

## 품질 기준

### 1. 개념 요약
- ✅ 길이: 100-500자
- ✅ 구체적인 예제 포함
- ✅ "무엇"뿐만 아니라 "왜" 설명
- ✅ 중급 개발자가 이해할 수 있는 수준
- ❌ 설명 없는 학술 전문 용어 불가
- ❌ 모호한 표현 불가 ("매우 효율적", "일반적으로 사용")

### 2. 핵심 공식
- ✅ 알고리즘당 2-4개 공식
- ✅ 각각 이름, 공식, 설명 포함
- ✅ 의사코드는 명확하고 실행 가능
- ✅ 설명은 언제/왜 설명 (50-100 단어)
- ❌ 맥락 없는 수학 표기법 불가
- ❌ 실용적 적용 없는 공식 불가

### 3. 사고 과정
- ✅ 최소 200자
- ✅ 번호가 매겨진 단계 사용 (5-7 단계 이상적)
- ✅ 인식 패턴 포함
- ✅ 엣지 케이스 다룸
- ✅ 결정 로직이 명시적
- ❌ 고수준 손 흔들기 불가
- ❌ "명백하다" 가정 불가

### 4. 적용 조건
- ✅ 3-5개 "언제 사용" 조건
- ✅ 2-3개 "언제 사용하지 말까" 조건
- ✅ 구체적인 입력/출력 특성
- ✅ 대안 패턴 언급
- ❌ 일반적인 조언 불가 ("빠른 솔루션이 필요할 때 사용")
- ❌ 모순되는 조건 불가

### 5. 복잡도 분석
- ✅ 유효한 Big-O 표기법 (정규식 일치: `O\(.+\)`)
- ✅ 추론 설명 (루프 횟수, 재귀 깊이)
- ✅ 시간 vs 공간 구별
- ✅ 해당되는 경우 최선/평균/최악 언급
- ❌ 설명되지 않은 표기법 불가
- ❌ 잘못된 복잡도 주장 불가

### 6. 문제 유형
- ✅ 3-5개 대표 문제 유형
- ✅ 각 유형은 2개 이상 LeetCode 예시
- ✅ 문제 번호와 정확한 제목 포함
- ✅ 난이도순 정렬
- ✅ 다양한 적용 사례 다룸
- ❌ 만들어낸 문제 제목 불가
- ❌ 유형 간 중복 예시 불가

### 7. 코드 템플릿
- ✅ 3개 언어 모두: Python, C++, Java
- ✅ 각 템플릿 ≥100자
- ✅ 컴파일/실행 가능한 코드 (의사코드 불가)
- ✅ 핵심 통찰이 있는 주석
- ✅ 주석에 샘플 사용 포함
- ✅ 적절한 포맷팅과 스타일
- ❌ 구문 오류 불가
- ❌ 플레이스홀더 주석 불가 ("// TODO")
- ❌ 언어 간 일관성 없는 네이밍 불가

#### Python 요구사항
- 타입 힌트 (Python 3.10+)
- 예제가 있는 Docstring
- PEP 8 준수
- 엣지 케이스 처리

#### C++ 요구사항
- 모던 C++17 기능
- 필요한 헤더 포함
- `std::` 네임스페이스 명시적
- 적절한 STL 사용

#### Java 요구사항
- Java 11+ 기능
- 클래스 구조 포함
- Google Java Style Guide
- 적절한 예외 처리

### 8. 주의사항
- ✅ 총 최소 150자
- ✅ 3-5개 구별되는 실수
- ✅ 각 실수는 다음 포함:
  - 설명 (무엇이 잘못되었나)
  - 근본 원인 (왜 발생하나)
  - 수정 (피하는 방법)
- ✅ 실용적이고 면접 관련 함정
- ❌ 일반적인 경고 불가 ("조심하세요")
- ❌ 템플릿과 모순되는 실수 불가

---

## JSON 스키마 검증

### 필수 필드
모든 필드는 존재하고 비어있지 않아야 함:
- title
- category
- difficulty
- concept_summary
- core_formulas (배열, 2-4 항목)
- thought_process
- application_conditions (when_to_use, when_not_to_use가 있는 객체)
- time_complexity
- space_complexity
- problem_types (배열, 3개 이상 항목)
- common_mistakes
- code_templates (python, cpp, java가 있는 객체)

### 필드 제약
- `concept_summary`: 100-500자
- `core_formulas`: 2-4 항목, 각각 name/formula/description
- `thought_process`: 200자 이상
- `application_conditions.when_to_use`: 3-5 항목
- `application_conditions.when_not_to_use`: 2-3 항목
- `time_complexity`: `O\(.+\)` 패턴 일치
- `space_complexity`: `O\(.+\)` 패턴 일치
- `problem_types`: 3개 이상 항목, 각각 type과 2개 이상 leetcode_examples
- `common_mistakes`: 150자 이상
- `code_templates.python`: 100자 이상
- `code_templates.cpp`: 100자 이상
- `code_templates.java`: 100자 이상

---

## 자동 검증 체크

### 1단계: 스키마 검증
Pydantic 스키마를 사용하여 구조와 타입 검증.

### 2단계: 콘텐츠 품질 체크
- 단어 수 검증
- 키워드 존재 (예: 복잡도의 "O(")
- LeetCode 문제 형식 검증 (정규식: `LC \d+\. .+`)
- 코드 구문 검증 (Python의 AST 파싱)

### 3단계: 수동 리뷰 트리거
다음의 경우 사람 리뷰를 위해 플래그 지정:
- 복잡도가 O(1) 또는 O(2^n) (드문 경우, 정확성 확인)
- 코드 템플릿 < 150자 (불완전할 가능성)
- 주의사항 < 200자 (일반적일 가능성)
- 엣지 케이스 처리 언급 없음
- 난이도 불일치 (예: O(2^n)이지만 "Easy" 난이도)

---

## 거부 기준

**자동 거부 조건**:
- 필수 필드 누락
- 스키마 검증 실패
- 코드 템플릿에 구문 오류
- LeetCode 예시가 형식과 일치하지 않음
- 복잡도 표기법 무효
- 콘텐츠 길이가 최소값 미만

**수정을 위한 플래그 조건**:
- 구체성 없는 일반적인 조언
- 모순되는 진술
- 불분명한 설명
- 엣지 케이스 처리 누락
- 코드 템플릿에 주석 부족
- 모호한 주의사항

---

## 품질 점수 루브릭 (0-100)

### 점수 구성요소
- **명확성** (20점): 개념 요약, 사고 과정 가독성
- **완전성** (20점): 8개 섹션 모두 완전히 개발
- **코드 품질** (20점): 템플릿이 프로덕션 준비됨
- **실용적 가치** (20점): 실제 면접 적용 가능성
- **정확성** (20점): 올바른 복잡도, 유효한 예시

### 임계값
- **90-100**: 우수, 즉시 게시
- **75-89**: 좋음, 사소한 수정 제안
- **60-74**: 수용 가능, 상당한 개선 필요
- **<60**: 거부, 개선된 프롬프트로 재생성

---

## 일반적인 AI 생성 문제

### 문제: 일반적인 콘텐츠
**증상**: "이 알고리즘은 유용합니다"와 같은 모호한 진술
**해결**: 구체적인 예시와 실제 시나리오 요청

### 문제: 잘못된 복잡도
**증상**: O(n log n)이라고 주장하지만 코드는 O(n²) 표시
**해결**: 수동 코드 리뷰, AI에게 줄별 설명 요청

### 문제: 엣지 케이스 누락
**증상**: 템플릿이 빈 입력을 처리하지 않음
**해결**: 프롬프트에 명시적인 엣지 케이스 요구사항 추가

### 문제: 일관성 없는 코드 스타일
**증상**: Python은 camelCase 사용, Java는 snake_case 사용
**해결**: 프롬프트에서 언어별 스타일 가이드 강제

### 문제: 오래된 LeetCode 문제
**증상**: 문제 번호가 존재하지 않거나 제목 불일치
**해결**: LeetCode API 또는 최근 문제 목록과 교차 참조

---

## 지속적인 개선

### 피드백 루프
1. 수동 수정이 필요한 알고리즘 추적
2. 카테고리별 일반적인 AI 실수 식별
3. 오류 패턴을 기반으로 프롬프트 개선
4. 패턴이 나타나면 검증 규칙 업데이트

### 버전 관리
- Git으로 프롬프트 버전 추적
- 어떤 프롬프트 버전으로 어떤 알고리즘이 생성되었는지 문서화
- 개선된 프롬프트로 오래된 콘텐츠 재생성
