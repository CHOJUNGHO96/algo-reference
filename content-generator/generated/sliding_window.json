{
  "title": "Sliding Window",
  "category": "Sliding Window",
  "difficulty": "Medium",
  "concept_summary": "The Sliding Window technique maintains a dynamic window (subarray or substring) that slides across the data structure, expanding or contracting based on constraints. Instead of recalculating from scratch for each position (O(n²)), we incrementally update the window state, achieving O(n) time. This pattern excels at finding optimal subarrays/substrings meeting specific conditions like maximum sum, minimum length, or character constraints.",
  "core_formulas": [
    {
      "name": "Fixed-Size Window",
      "formula": "window_sum = sum(arr[0:k]); for i in range(k, n): window_sum = window_sum - arr[i-k] + arr[i]; update_max(window_sum)",
      "description": "Maintain window of constant size k. Slide by removing leftmost element and adding rightmost element. Used for finding maximum/minimum sum of k consecutive elements, or k-element statistics."
    },
    {
      "name": "Variable-Size Window (Two Pointers)",
      "formula": "left = 0; for right in range(n): add arr[right] to window; while invalid_condition: remove arr[left]; left++; update_result",
      "description": "Window expands by moving right pointer, contracts from left when constraint violated. Used for longest/shortest subarray with sum/character constraints. More flexible than fixed-size."
    },
    {
      "name": "Window State Tracking",
      "formula": "state = {}; for right in range(n): update state with arr[right]; while state invalid: revert arr[left]; left++; process valid state",
      "description": "Track window state using hash map (character frequencies, sum, etc.). Essential for substring problems with character constraints like 'at most k distinct' or 'no repeating characters'."
    }
  ],
  "thought_process": "1. **Recognition**: Identify contiguous subarray/substring optimization, constraint-based window (sum, length, characters), or 'find longest/shortest' pattern.\n\n2. **Window Type Selection**: Choose fixed-size for exact k elements, variable-size for longest/shortest meeting condition.\n\n3. **State Design**: Decide what to track - simple sum, hash map for frequencies, set for distinct elements, or custom state.\n\n4. **Window Expansion**: Add right element to window, update state (increment frequency, add to sum, add to set).\n\n5. **Constraint Validation**: Check if window violates constraint (sum exceeds target, too many distinct chars, has duplicates).\n\n6. **Window Contraction**: While invalid, remove left element, update state, increment left pointer. Continue until valid.\n\n7. **Result Update**: For valid window, update global result (max length, min length, max sum, found substring).\n\n8. **Edge Cases**: Empty input, single element, all elements same, no valid window exists, entire array is answer.",
  "application_conditions": {
    "when_to_use": [
      "Finding optimal contiguous subarray (longest, shortest, maximum sum, minimum sum)",
      "Substring problems with character constraints (distinct chars, repeating chars, anagrams)",
      "Fixed-size window statistics (max sum of k elements, average of k elements)",
      "Problems with 'at most k', 'exactly k', or 'longest/shortest' in description",
      "Replacing nested loops that check all subarrays (optimization from O(n²) to O(n))"
    ],
    "when_not_to_use": [
      "Non-contiguous subsequences (use dynamic programming instead)",
      "Global optimum requiring backtracking (use DP or greedy)",
      "Problems needing arbitrary element access or rearrangement"
    ]
  },
  "time_complexity": "O(n) - Each element enters window once (right pointer) and leaves once (left pointer). Hash map operations are O(1). Total 2n operations regardless of window contractions.",
  "space_complexity": "O(k) - Hash map stores at most k distinct elements (window size or character set). For fixed numeric sum, O(1). Worst case O(min(n, alphabet_size)) for character problems.",
  "problem_types": [
    {
      "type": "Fixed-Size Window Maximum/Minimum",
      "leetcode_examples": [
        "LC 643. Maximum Average Subarray I",
        "LC 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold"
      ]
    },
    {
      "type": "Longest Substring with Constraints",
      "leetcode_examples": [
        "LC 3. Longest Substring Without Repeating Characters",
        "LC 340. Longest Substring with At Most K Distinct Characters",
        "LC 424. Longest Repeating Character Replacement"
      ]
    },
    {
      "type": "Shortest Subarray Meeting Condition",
      "leetcode_examples": [
        "LC 209. Minimum Size Subarray Sum",
        "LC 862. Shortest Subarray with Sum at Least K"
      ]
    },
    {
      "type": "Substring Anagram/Permutation",
      "leetcode_examples": [
        "LC 438. Find All Anagrams in a String",
        "LC 567. Permutation in String",
        "LC 76. Minimum Window Substring"
      ]
    },
    {
      "type": "Count Valid Subarrays",
      "leetcode_examples": [
        "LC 992. Subarrays with K Different Integers",
        "LC 1248. Count Number of Nice Subarrays"
      ]
    }
  ],
  "common_mistakes": "❌ **Recalculating Window State from Scratch**: Computing sum or checking entire window each iteration instead of incremental updates. Leads to O(n×k) instead of O(n).\n✅ **Fix**: Maintain running state. For sum: `window_sum += arr[right]; window_sum -= arr[left]`. For frequency: update hash map incrementally.\n\n❌ **Incorrect Window Contraction Logic**: Using `if` instead of `while` for shrinking window, causing premature termination when multiple contractions needed.\n✅ **Fix**: Use `while invalid_condition:` not `if invalid_condition:`. Window may need multiple left increments to become valid.\n\n❌ **Off-by-One in Fixed Window**: Starting result update before window reaches size k, or incorrect initialization of first window.\n✅ **Fix**: Calculate first window separately: `window_sum = sum(arr[0:k])`, then slide from index k onwards.\n\n❌ **Forgetting to Update Result for Last Window**: Missing result check after loop ends, especially for 'found' boolean problems.\n✅ **Fix**: For 'exists' problems, check condition both in loop and after. For min/max, ensure all valid windows compared.\n\n❌ **State Cleanup Errors**: Not properly reverting state when removing left element (forgetting to decrement frequency, remove from set).\n✅ **Fix**: Mirror the add operation. If `state[arr[right]]++` on add, do `state[arr[left]]--` on remove. Clean up zero-count entries.",
  "code_templates": {
    "python": "def max_subarray_sum_size_k(arr: list[int], k: int) -> int:\n    \"\"\"\n    Find maximum sum of any contiguous subarray of size k.\n    \n    Args:\n        arr: Array of integers\n        k: Window size\n    \n    Returns:\n        Maximum sum of k consecutive elements\n    \n    Time: O(n), Space: O(1)\n    \n    Example:\n        >>> max_subarray_sum_size_k([1, 4, 2, 10, 23, 3, 1, 0, 20], 4)\n        39  # [10, 23, 3, 1]\n    \"\"\"\n    if not arr or k > len(arr):\n        return 0\n    \n    # Calculate first window\n    window_sum = sum(arr[:k])\n    max_sum = window_sum\n    \n    # Slide window: remove left, add right\n    for i in range(k, len(arr)):\n        window_sum = window_sum - arr[i - k] + arr[i]\n        max_sum = max(max_sum, window_sum)\n    \n    return max_sum\n\n\ndef longest_substring_k_distinct(s: str, k: int) -> int:\n    \"\"\"\n    Find longest substring with at most k distinct characters.\n    \n    Args:\n        s: Input string\n        k: Maximum distinct characters allowed\n    \n    Returns:\n        Length of longest valid substring\n    \n    Time: O(n), Space: O(k)\n    \n    Example:\n        >>> longest_substring_k_distinct(\"eceba\", 2)\n        3  # \"ece\"\n    \"\"\"\n    if not s or k == 0:\n        return 0\n    \n    char_count = {}\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        # Expand window: add right character\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        \n        # Contract window: remove from left while invalid\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        # Update result with valid window\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length",
    "cpp": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass SlidingWindowSolution {\npublic:\n    /**\n     * Find maximum sum of any contiguous subarray of size k.\n     * Time: O(n), Space: O(1)\n     */\n    int maxSubarraySumSizeK(vector<int>& arr, int k) {\n        if (arr.empty() || k > arr.size()) return 0;\n        \n        // Calculate first window\n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += arr[i];\n        }\n        int maxSum = windowSum;\n        \n        // Slide window: remove left, add right\n        for (int i = k; i < arr.size(); i++) {\n            windowSum = windowSum - arr[i - k] + arr[i];\n            maxSum = max(maxSum, windowSum);\n        }\n        \n        return maxSum;\n    }\n    \n    /**\n     * Find longest substring with at most k distinct characters.\n     * Time: O(n), Space: O(k)\n     */\n    int longestSubstringKDistinct(string s, int k) {\n        if (s.empty() || k == 0) return 0;\n        \n        unordered_map<char, int> charCount;\n        int left = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            // Expand window: add right character\n            charCount[s[right]]++;\n            \n            // Contract window: remove from left while invalid\n            while (charCount.size() > k) {\n                charCount[s[left]]--;\n                if (charCount[s[left]] == 0) {\n                    charCount.erase(s[left]);\n                }\n                left++;\n            }\n            \n            // Update result with valid window\n            maxLength = max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n};",
    "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SlidingWindowSolution {\n    /**\n     * Find maximum sum of any contiguous subarray of size k.\n     * Time: O(n), Space: O(1)\n     */\n    public int maxSubarraySumSizeK(int[] arr, int k) {\n        if (arr.length == 0 || k > arr.length) return 0;\n        \n        // Calculate first window\n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += arr[i];\n        }\n        int maxSum = windowSum;\n        \n        // Slide window: remove left, add right\n        for (int i = k; i < arr.length; i++) {\n            windowSum = windowSum - arr[i - k] + arr[i];\n            maxSum = Math.max(maxSum, windowSum);\n        }\n        \n        return maxSum;\n    }\n    \n    /**\n     * Find longest substring with at most k distinct characters.\n     * Time: O(n), Space: O(k)\n     */\n    public int longestSubstringKDistinct(String s, int k) {\n        if (s.isEmpty() || k == 0) return 0;\n        \n        Map<Character, Integer> charCount = new HashMap<>();\n        int left = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            // Expand window: add right character\n            charCount.put(s.charAt(right), \n                charCount.getOrDefault(s.charAt(right), 0) + 1);\n            \n            // Contract window: remove from left while invalid\n            while (charCount.size() > k) {\n                charCount.put(s.charAt(left), \n                    charCount.get(s.charAt(left)) - 1);\n                if (charCount.get(s.charAt(left)) == 0) {\n                    charCount.remove(s.charAt(left));\n                }\n                left++;\n            }\n            \n            // Update result with valid window\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n}"
  }
}
