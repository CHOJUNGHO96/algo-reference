{
  "title": "Two Pointer Technique",
  "category": "Two Pointer",
  "difficulty": "Medium",
  "concept_summary": "The Two Pointer technique uses two pointers to traverse data structures in a coordinated manner, typically moving from opposite ends or in the same direction at different speeds. This approach transforms O(n²) brute force solutions into O(n) linear time by intelligently eliminating unnecessary comparisons. It's particularly powerful for sorted arrays, linked lists, and problems requiring pair/triplet detection.",
  "core_formulas": [
    {
      "name": "Opposite Direction Pattern",
      "formula": "left = 0, right = n-1; while left < right: if arr[left] + arr[right] == target: return; elif sum < target: left++; else: right--",
      "description": "Start pointers at both ends and converge toward center. Move left pointer right when sum is too small, move right pointer left when sum is too large. Used for pair sum problems in sorted arrays, palindrome validation, and container problems."
    },
    {
      "name": "Same Direction (Slow-Fast) Pattern",
      "formula": "slow = 0, fast = 0; while fast < n: if condition(arr[fast]): arr[slow] = arr[fast]; slow++; fast++",
      "description": "Both pointers move forward, with fast pointer exploring ahead while slow pointer maintains valid state. Used for in-place array modifications, removing duplicates, partitioning, and cycle detection in linked lists."
    },
    {
      "name": "Window Expansion Pattern",
      "formula": "left = 0, right = 0; while right < n: expand window with arr[right]; while invalid: shrink from left; right++",
      "description": "Expand window by moving right pointer, shrink window from left when constraint violated. Bridge between two pointers and sliding window techniques."
    }
  ],
  "thought_process": "1. **Recognition**: Identify sorted array, pair/triplet sum target, palindrome checks, in-place modifications, or partitioning requirements.\n\n2. **Pattern Selection**: Choose opposite direction for sorted pair sums, same direction for in-place operations, or window expansion for constraint-based problems.\n\n3. **Initialization**: Set pointers based on pattern - (0, n-1) for opposite direction, (0, 0) for same direction.\n\n4. **Main Loop**: Continue while pointers haven't crossed (opposite) or fast pointer hasn't reached end (same direction).\n\n5. **Decision Logic**: Compare elements at pointer positions. For pair sum: if sum < target move left++, if sum > target move right--, if equal record result. For in-place: if element valid copy to slow position and increment slow, always increment fast.\n\n6. **Edge Cases**: Handle empty arrays, single elements, all duplicates, no valid pairs, and pointer crossing conditions.\n\n7. **Termination**: Stop when pointers meet/cross (opposite) or fast reaches end (same direction).",
  "application_conditions": {
    "when_to_use": [
      "Sorted array with pair, triplet, or quadruplet sum targets",
      "Palindrome validation for strings or linked lists",
      "In-place array partitioning or element removal",
      "Container with most water or trapping rain water problems",
      "Removing duplicates from sorted arrays"
    ],
    "when_not_to_use": [
      "Unsorted data requiring arbitrary element access patterns",
      "Problems needing frequency counting or element grouping (use hash map)",
      "Complex state tracking across multiple positions (consider DP or other approaches)"
    ]
  },
  "time_complexity": "O(n) - Single pass through array with two pointers, each element visited at most once. No nested loops despite having two pointers.",
  "space_complexity": "O(1) - Only using two integer pointer variables regardless of input size. In-place modifications mean no auxiliary data structures.",
  "problem_types": [
    {
      "type": "Pair Sum in Sorted Array",
      "leetcode_examples": [
        "LC 167. Two Sum II - Input Array Is Sorted",
        "LC 653. Two Sum IV - BST",
        "LC 1. Two Sum (can be solved with pointers after sorting)"
      ]
    },
    {
      "type": "Triplet/Quadruplet Sum",
      "leetcode_examples": [
        "LC 15. 3Sum",
        "LC 16. 3Sum Closest",
        "LC 18. 4Sum"
      ]
    },
    {
      "type": "Palindrome Validation",
      "leetcode_examples": [
        "LC 125. Valid Palindrome",
        "LC 680. Valid Palindrome II",
        "LC 234. Palindrome Linked List"
      ]
    },
    {
      "type": "Container and Water Problems",
      "leetcode_examples": [
        "LC 11. Container With Most Water",
        "LC 42. Trapping Rain Water"
      ]
    },
    {
      "type": "In-Place Array Modification",
      "leetcode_examples": [
        "LC 26. Remove Duplicates from Sorted Array",
        "LC 27. Remove Element",
        "LC 283. Move Zeroes",
        "LC 75. Sort Colors"
      ]
    }
  ],
  "common_mistakes": "❌ **Off-by-One Errors in Loop Conditions**: Using `<=` instead of `<` in `while left < right`, or incorrect initial positions like `right = n` instead of `n-1`. This causes array index out of bounds or skips valid pairs.\n✅ **Fix**: Draw examples with arrays of size 0, 1, 2 to verify boundary conditions. Use `while left < right` for opposite direction.\n\n❌ **Moving Both Pointers Simultaneously**: Moving both left and right pointers in same iteration (e.g., `left++; right--` without condition) causes skipping of valid pairs in the middle.\n✅ **Fix**: Only move one pointer per iteration based on comparison result. For pair sum, move left if sum too small, right if too large.\n\n❌ **Not Handling Duplicates in 3Sum/4Sum**: Forgetting to skip duplicate elements leads to duplicate triplets/quadruplets in result set.\n✅ **Fix**: After finding valid result, use `while (left < right && arr[left] == arr[left+1]) left++` to skip duplicates.\n\n❌ **Modifying Sorted Array Assumption**: Applying two pointer technique to unsorted arrays expecting O(n) solution. Two pointers require sorted data for correctness.\n✅ **Fix**: Sort array first (O(n log n)) or use hash map approach for unsorted data.\n\n❌ **Confusing Slow-Fast with Index Tracking**: Using slow pointer as counter instead of position marker in in-place modifications.\n✅ **Fix**: Remember slow pointer marks next valid position, not count. Use `arr[slow] = arr[fast]` pattern, not `count++`.",
  "code_templates": {
    "python": "def two_sum_sorted(arr: list[int], target: int) -> list[int]:\n    \"\"\"\n    Find two numbers in sorted array that sum to target.\n    \n    Args:\n        arr: Sorted array of integers\n        target: Target sum value\n    \n    Returns:\n        Indices [left, right] of two numbers, or [-1, -1] if not found\n    \n    Time: O(n), Space: O(1)\n    \n    Example:\n        >>> two_sum_sorted([2, 7, 11, 15], 9)\n        [0, 1]\n        >>> two_sum_sorted([2, 3, 4], 6)\n        [0, 2]\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1  # Need larger sum, move left pointer right\n        else:\n            right -= 1  # Need smaller sum, move right pointer left\n    \n    return [-1, -1]  # No solution found\n\n\ndef remove_duplicates(arr: list[int]) -> int:\n    \"\"\"\n    Remove duplicates from sorted array in-place using slow-fast pointers.\n    \n    Args:\n        arr: Sorted array with possible duplicates\n    \n    Returns:\n        Length of array after removing duplicates\n    \n    Time: O(n), Space: O(1)\n    \n    Example:\n        >>> nums = [1, 1, 2, 2, 3]\n        >>> k = remove_duplicates(nums)\n        >>> nums[:k]\n        [1, 2, 3]\n    \"\"\"\n    if not arr:\n        return 0\n    \n    # Slow pointer marks next position for unique element\n    slow = 1\n    \n    # Fast pointer explores ahead\n    for fast in range(1, len(arr)):\n        # Found new unique element\n        if arr[fast] != arr[fast - 1]:\n            arr[slow] = arr[fast]\n            slow += 1\n    \n    return slow  # Length of unique elements",
    "cpp": "#include <vector>\nusing namespace std;\n\nclass TwoPointerSolution {\npublic:\n    /**\n     * Find two numbers in sorted array that sum to target.\n     * Time: O(n), Space: O(1)\n     * \n     * @param arr Sorted vector of integers\n     * @param target Target sum value\n     * @return Vector with two indices, or {-1, -1} if not found\n     */\n    vector<int> twoSumSorted(vector<int>& arr, int target) {\n        int left = 0, right = arr.size() - 1;\n        \n        while (left < right) {\n            int currentSum = arr[left] + arr[right];\n            \n            if (currentSum == target) {\n                return {left, right};\n            } else if (currentSum < target) {\n                left++;  // Need larger sum\n            } else {\n                right--;  // Need smaller sum\n            }\n        }\n        \n        return {-1, -1};  // No solution found\n    }\n    \n    /**\n     * Remove duplicates from sorted array in-place.\n     * Time: O(n), Space: O(1)\n     * \n     * @param arr Sorted vector with possible duplicates\n     * @return Length of array after removing duplicates\n     */\n    int removeDuplicates(vector<int>& arr) {\n        if (arr.empty()) return 0;\n        \n        int slow = 1;  // Next position for unique element\n        \n        for (int fast = 1; fast < arr.size(); fast++) {\n            // Found new unique element\n            if (arr[fast] != arr[fast - 1]) {\n                arr[slow] = arr[fast];\n                slow++;\n            }\n        }\n        \n        return slow;\n    }\n};",
    "java": "import java.util.Arrays;\n\npublic class TwoPointerSolution {\n    /**\n     * Find two numbers in sorted array that sum to target.\n     * Time: O(n), Space: O(1)\n     * \n     * @param arr Sorted array of integers\n     * @param target Target sum value\n     * @return Array with two indices, or {-1, -1} if not found\n     */\n    public int[] twoSumSorted(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        \n        while (left < right) {\n            int currentSum = arr[left] + arr[right];\n            \n            if (currentSum == target) {\n                return new int[]{left, right};\n            } else if (currentSum < target) {\n                left++;  // Need larger sum\n            } else {\n                right--;  // Need smaller sum\n            }\n        }\n        \n        return new int[]{-1, -1};  // No solution found\n    }\n    \n    /**\n     * Remove duplicates from sorted array in-place.\n     * Time: O(n), Space: O(1)\n     * \n     * @param arr Sorted array with possible duplicates\n     * @return Length of array after removing duplicates\n     */\n    public int removeDuplicates(int[] arr) {\n        if (arr.length == 0) return 0;\n        \n        int slow = 1;  // Next position for unique element\n        \n        for (int fast = 1; fast < arr.length; fast++) {\n            // Found new unique element\n            if (arr[fast] != arr[fast - 1]) {\n                arr[slow] = arr[fast];\n                slow++;\n            }\n        }\n        \n        return slow;\n    }\n}"
  }
}
