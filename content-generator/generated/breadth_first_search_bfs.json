{
  "title": "Breadth-First Search (BFS)",
  "category": "Tree/Graph",
  "difficulty": "Medium",
  "concept_summary": "Breadth-First Search (BFS) is a graph traversal algorithm that explores nodes level by level, visiting all neighbors at the current depth before moving to the next level. It uses a queue data structure (FIFO - First In First Out) to maintain the exploration order. BFS guarantees finding the shortest path in unweighted graphs and is essential for level-order traversal, minimum depth problems, and problems requiring exploration by distance from source. Unlike DFS which goes deep, BFS explores wide, making it optimal for shortest path and nearest neighbor problems.",
  "core_formulas": [
    {
      "name": "Standard BFS Template",
      "formula": "queue = [start]; visited = {start}; while queue: node = queue.popleft(); process(node); for neighbor in node.neighbors: if neighbor not in visited: visited.add(neighbor); queue.append(neighbor)",
      "description": "Classic BFS using queue (deque in Python). Mark node visited when adding to queue (not when processing) to prevent duplicate additions. Process nodes in FIFO order ensuring level-by-level exploration. Use for shortest path, level traversal, and distance-based problems."
    },
    {
      "name": "Level-Order BFS",
      "formula": "queue = [root]; while queue: level_size = len(queue); level = []; for _ in range(level_size): node = queue.popleft(); level.append(node.val); add children to queue; results.append(level)",
      "description": "BFS that tracks levels explicitly by processing one complete level before next. Snapshot queue size at start of each level. Essential for problems requiring level information, zigzag traversal, or level-wise operations. Returns list of levels."
    },
    {
      "name": "BFS with Distance Tracking",
      "formula": "queue = [(start, 0)]; visited = {start}; while queue: node, dist = queue.popleft(); if node == target: return dist; for neighbor in neighbors: if neighbor not in visited: visited.add(neighbor); queue.append((neighbor, dist+1))",
      "description": "BFS that tracks distance from source. Store (node, distance) tuples in queue. Distance increases by 1 for each level. Guarantees shortest path in unweighted graphs. Use for minimum steps, shortest path length, or problems requiring distance information."
    }
  ],
  "thought_process": "1. **Problem Analysis**: Identify if problem requires level-order traversal, shortest path, or minimum depth. BFS is optimal for these patterns.\n\n2. **Queue Initialization**: Initialize queue with starting node(s). For single source, use `queue = [start]`. For multiple sources (multi-source BFS), add all sources initially.\n\n3. **Visited Tracking**: Initialize visited set with starting nodes. Mark visited when adding to queue, not when processing, to prevent duplicate queue entries.\n\n4. **Level Tracking Decision**: Determine if levels matter. If yes, use level-order template with level size snapshot. If no, use standard BFS.\n\n5. **Queue Processing**: While queue not empty, dequeue node (FIFO order). Process node (collect value, check condition, etc.).\n\n6. **Neighbor Exploration**: Iterate through all neighbors/children. For unvisited neighbors, mark visited and add to queue. Order of adding affects tie-breaking but not correctness.\n\n7. **Distance/Path Tracking**: For shortest path, track distance or parent pointers. Distance increments by 1 each level. Reconstruct path using parent pointers if needed.\n\n8. **Termination**: BFS naturally terminates when queue empty (all reachable nodes explored) or when target found (early termination for search problems).",
  "application_conditions": {
    "when_to_use": [
      "Finding shortest path in unweighted graphs (guaranteed optimal)",
      "Level-order tree traversal or problems requiring level information",
      "Finding minimum depth or distance from source",
      "Problems requiring exploration by layers or distance",
      "Multi-source BFS (flood fill, rotting oranges, nearest exit)",
      "Finding nearest neighbor or closest node with property",
      "Detecting if path exists with minimum steps"
    ],
    "when_not_to_use": [
      "Graph has weighted edges (use Dijkstra instead for optimal path)",
      "Need to explore all paths or backtracking (use DFS)",
      "Memory constrained with wide graphs (BFS uses O(w) space, DFS uses O(h))",
      "Tree problems not requiring level info (DFS may be simpler)",
      "Finding any path without shortest requirement (DFS sufficient)"
    ]
  },
  "time_complexity": "O(V + E) - Visit each vertex V once and explore each edge E once. For trees, E = V-1 so O(V). For dense graphs, E ≈ V² so O(V²). Same as DFS but explores in breadth-first order.",
  "space_complexity": "O(V) - Queue stores up to V vertices. Visited set stores V vertices. Worst case for trees is O(w) where w is maximum width at any level. For complete binary tree, w = V/2 at last level, so O(V). Trade-off: BFS uses more space than DFS (O(h)) but guarantees shortest path.",
  "problem_types": [
    {
      "type": "Level-Order Traversal",
      "leetcode_examples": [
        "LC 102. Binary Tree Level Order Traversal",
        "LC 103. Binary Tree Zigzag Level Order Traversal",
        "LC 107. Binary Tree Level Order Traversal II",
        "LC 199. Binary Tree Right Side View"
      ]
    },
    {
      "type": "Shortest Path in Unweighted Graph",
      "leetcode_examples": [
        "LC 127. Word Ladder",
        "LC 433. Minimum Genetic Mutation",
        "LC 752. Open the Lock",
        "LC 1091. Shortest Path in Binary Matrix"
      ]
    },
    {
      "type": "Minimum Depth and Distance",
      "leetcode_examples": [
        "LC 111. Minimum Depth of Binary Tree",
        "LC 542. 01 Matrix",
        "LC 1162. As Far from Land as Possible"
      ]
    },
    {
      "type": "Multi-Source BFS",
      "leetcode_examples": [
        "LC 994. Rotting Oranges",
        "LC 1765. Map of Highest Peak",
        "LC 317. Shortest Distance from All Buildings"
      ]
    },
    {
      "type": "Grid and Maze Problems",
      "leetcode_examples": [
        "LC 200. Number of Islands",
        "LC 286. Walls and Gates",
        "LC 1293. Shortest Path in a Grid with Obstacles Elimination",
        "LC 1926. Nearest Exit from Entrance in Maze"
      ]
    }
  ],
  "common_mistakes": "❌ **Marking Visited When Processing Instead of Adding**: Marking node visited only when dequeuing causes duplicate entries in queue, leading to O(V²) time and potential infinite loops.\n✅ **Fix**: Mark visited immediately when adding to queue: `if neighbor not in visited: visited.add(neighbor); queue.append(neighbor)`. This prevents duplicates.\n\n❌ **Using List Instead of Deque for Queue**: Using list with `pop(0)` for dequeue is O(n) operation, making BFS O(V×E) instead of O(V+E).\n✅ **Fix**: Use `collections.deque` with `popleft()` which is O(1): `from collections import deque; queue = deque([start])`.\n\n❌ **Wrong Level Size Calculation**: Calculating level size inside loop or after processing nodes gives incorrect level boundaries.\n✅ **Fix**: Snapshot level size before processing: `level_size = len(queue)` then `for _ in range(level_size):`. This ensures current level fully processed before next.\n\n❌ **Not Handling Multi-Source BFS Correctly**: Adding sources one by one or marking wrong initial distance causes incorrect shortest paths from multiple sources.\n✅ **Fix**: Add all sources to queue initially: `queue = deque(all_sources)`. Mark all as visited with distance 0. BFS naturally finds min distance to any source.\n\n❌ **Forgetting Early Termination for Search**: Continuing BFS after finding target wastes time exploring remaining nodes.\n✅ **Fix**: Return immediately when target found in shortest path problems: `if node == target: return distance`. For existence checks, return True when found.",
  "code_templates": {
    "python": "from collections import deque\nfrom typing import Optional, List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]:\n    \"\"\"\n    BFS level-order traversal returning list of levels.\n    \n    Args:\n        root: Root node of binary tree\n    \n    Returns:\n        List of lists, each inner list is one level\n    \n    Time: O(n), Space: O(w) where w is max width\n    \n    Example:\n        >>> tree = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n        >>> level_order_traversal(tree)\n        [[3], [9, 20], [15, 7]]\n    \"\"\"\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)  # Snapshot current level size\n        level = []\n        \n        # Process all nodes in current level\n        for _ in range(level_size):\n            node = queue.popleft()\n            level.append(node.val)\n            \n            # Add children for next level\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result\n\ndef min_depth(root: Optional[TreeNode]) -> int:\n    \"\"\"\n    Find minimum depth (shortest path to leaf) using BFS.\n    \n    Args:\n        root: Root of binary tree\n    \n    Returns:\n        Minimum depth from root to any leaf\n    \n    Time: O(n), Space: O(w)\n    \n    Example:\n        >>> tree = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n        >>> min_depth(tree)\n        2\n    \"\"\"\n    if not root:\n        return 0\n    \n    queue = deque([(root, 1)])  # (node, depth)\n    \n    while queue:\n        node, depth = queue.popleft()\n        \n        # First leaf found is at minimum depth (BFS property)\n        if not node.left and not node.right:\n            return depth\n        \n        if node.left:\n            queue.append((node.left, depth + 1))\n        if node.right:\n            queue.append((node.right, depth + 1))\n    \n    return 0\n\ndef shortest_path_grid(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find shortest path in grid from top-left to bottom-right.\n    Grid[i][j] = 0 means walkable, 1 means obstacle.\n    \n    Args:\n        grid: 2D grid with 0s (walkable) and 1s (obstacles)\n    \n    Returns:\n        Length of shortest path, or -1 if no path exists\n    \n    Time: O(m*n), Space: O(m*n)\n    \n    Example:\n        >>> grid = [[0,0,0],[1,1,0],[0,0,0]]\n        >>> shortest_path_grid(grid)\n        5\n    \"\"\"\n    if not grid or grid[0][0] == 1:\n        return -1\n    \n    m, n = len(grid), len(grid[0])\n    queue = deque([(0, 0, 1)])  # (row, col, distance)\n    visited = {(0, 0)}\n    directions = [(0,1), (1,0), (0,-1), (-1,0)]\n    \n    while queue:\n        row, col, dist = queue.popleft()\n        \n        # Reached bottom-right\n        if row == m-1 and col == n-1:\n            return dist\n        \n        # Explore 4 directions\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            # Check bounds and validity\n            if (0 <= new_row < m and 0 <= new_col < n and \n                grid[new_row][new_col] == 0 and \n                (new_row, new_col) not in visited):\n                \n                visited.add((new_row, new_col))\n                queue.append((new_row, new_col, dist + 1))\n    \n    return -1  # No path found",
    "cpp": "#include <vector>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass BFSSolution {\npublic:\n    /**\n     * BFS level-order traversal.\n     * Time: O(n), Space: O(w)\n     */\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> result;\n        if (!root) return result;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            int levelSize = q.size();\n            vector<int> level;\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                level.push_back(node->val);\n                \n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            \n            result.push_back(level);\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Find minimum depth using BFS.\n     * Time: O(n), Space: O(w)\n     */\n    int minDepth(TreeNode* root) {\n        if (!root) return 0;\n        \n        queue<pair<TreeNode*, int>> q;\n        q.push({root, 1});\n        \n        while (!q.empty()) {\n            auto [node, depth] = q.front();\n            q.pop();\n            \n            // First leaf is minimum depth\n            if (!node->left && !node->right) {\n                return depth;\n            }\n            \n            if (node->left) q.push({node->left, depth + 1});\n            if (node->right) q.push({node->right, depth + 1});\n        }\n        \n        return 0;\n    }\n    \n    /**\n     * Shortest path in grid using BFS.\n     * Time: O(m*n), Space: O(m*n)\n     */\n    int shortestPathGrid(vector<vector<int>>& grid) {\n        if (grid.empty() || grid[0][0] == 1) return -1;\n        \n        int m = grid.size(), n = grid[0].size();\n        queue<tuple<int, int, int>> q;  // row, col, distance\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        vector<pair<int, int>> directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n        \n        q.push({0, 0, 1});\n        visited[0][0] = true;\n        \n        while (!q.empty()) {\n            auto [row, col, dist] = q.front();\n            q.pop();\n            \n            if (row == m-1 && col == n-1) {\n                return dist;\n            }\n            \n            for (auto [dr, dc] : directions) {\n                int newRow = row + dr, newCol = col + dc;\n                \n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n &&\n                    grid[newRow][newCol] == 0 && !visited[newRow][newCol]) {\n                    \n                    visited[newRow][newCol] = true;\n                    q.push({newRow, newCol, dist + 1});\n                }\n            }\n        }\n        \n        return -1;\n    }\n};",
    "java": "import java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class BFSSolution {\n    /**\n     * BFS level-order traversal.\n     * Time: O(n), Space: O(w)\n     */\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List<Integer> level = new ArrayList<>();\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                level.add(node.val);\n                \n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            \n            result.add(level);\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Find minimum depth using BFS.\n     * Time: O(n), Space: O(w)\n     */\n    public int minDepth(TreeNode root) {\n        if (root == null) return 0;\n        \n        Queue<Pair> queue = new LinkedList<>();\n        queue.offer(new Pair(root, 1));\n        \n        while (!queue.isEmpty()) {\n            Pair p = queue.poll();\n            TreeNode node = p.node;\n            int depth = p.depth;\n            \n            // First leaf is minimum depth\n            if (node.left == null && node.right == null) {\n                return depth;\n            }\n            \n            if (node.left != null) queue.offer(new Pair(node.left, depth + 1));\n            if (node.right != null) queue.offer(new Pair(node.right, depth + 1));\n        }\n        \n        return 0;\n    }\n    \n    private static class Pair {\n        TreeNode node;\n        int depth;\n        Pair(TreeNode node, int depth) {\n            this.node = node;\n            this.depth = depth;\n        }\n    }\n}"
  }
}
